# Fish Music
这是一个为你定制的、标准化的 **软件需求规格说明书 (SRS/PRD)**。你可以直接用这份文档作为开发的蓝图，或者将来交给其他协助开发者使用。

---

# 项目名称：Fish-Music (Telegram 个人云音乐机器人)

**版本号**：v1.0

**日期**：2026-02-07

**技术栈**：Golang / PostgreSQL / Docker

---

## 1. 项目概述 (Project Overview)

### 1.1 背景

本项目旨在利用 Telegram 的无限云存储特性，构建一个个人专属的音乐库。通过 VPS 作为中转站，将外部音乐资源下载、刮削元数据后上传至 Telegram，利用 `File_ID` 实现“一次下载，永久秒播”。

### 1.2 核心目标

* **私有云库**：建立持久化的个人音乐索引数据库。
* **中转即焚**：VPS 仅作临时处理，处理完毕立即释放空间，低成本运行。
* **极致体验**：支持元数据刮削（封面、歌词、地区）、收藏、历史记录及 Web 端补档管理。

---

## 2. 系统架构需求 (System Architecture)

### 2.1 运行环境

* **后端语言**：Golang (1.20+)
* **数据库**：PostgreSQL
* **外部工具**：`yt-dlp` (下载源), `ffmpeg` (音频处理)
* **配置方式**：基于文件的配置 (`config.yaml`)，不依赖数据库启动。

### 2.2 模块划分

1. **Bot 交互层**：处理 TG 消息、命令、回调查询。
2. **业务逻辑层**：处理搜索、下载队列、元数据注入、上传中转。
3. **数据持久层**：PostgreSQL 读写（歌曲索引、用户数据）。
4. **Web 管理层**：端口 `9999`，提供后台看板与补档功能。

---

## 3. 功能需求 (Functional Requirements)

### 3.1 机器人端 (Telegram Bot)

#### 3.1.1 搜索与播放 (核心)

* **触发方式**：
* **私聊模式**：直接发送文本（如“周杰伦 稻香”）。
* **行内模式 (Inline Mode)**：在任意聊天窗口输入 `@BotName 关键词` 唤起搜索面板。


* **逻辑流程**：
1. **优先查库**：检索 PostgreSQL，若存在有效 `File_ID`，直接发送音频（秒回）。
2. **网络搜索**：若库内无数据，调用外部 API 进行检索，返回候选列表。
3. **下载中转**：用户点击下载 -> VPS 下载 -> 写入 ID3 (封面/歌词) -> 上传 TG -> **存库并删除本地文件**。


* **结果展示**：
* 必须使用 **Inline Keyboard** 进行交互。
* 列表需支持**分页**（每页 5-10 条，底部含 `[上一页] [页码] [下一页]` 按钮）。



#### 3.1.2 音乐元数据 (Metadata)

* **文件处理**：上传前必须通过 `ffmpeg` 写入 ID3 标签。
* **字段要求**：
* **封面 (Cover)**：必须嵌入高清专辑图。
* **标题/歌手**：准确对应。
* **地区 (Country)**：自动识别歌手所属地，展示为 Emoji (如 🇨🇳, 🇯🇵, 🇺🇸)。
* **年份 (Year)**：格式化为中文（如 `2004年`）。
* **歌词 (Lyrics)**：
* 短歌词：直接写入音频文件的 Lyrics 标签或 Caption。
* 长歌词：提供 Telegraph 链接或 `.lrc` 文件下载。





#### 3.1.3 用户交互功能

* **收藏系统**：播放卡片下方需有 `❤️ 收藏` 按钮，点击后存入数据库。
* **播放历史**：自动记录用户最近播放/下载的歌曲，提供 `/history` 命令查询。
* **随机推荐**：提供 `/random` 命令，从库中随机返回一首歌曲。

### 3.2 Web 管理端 (Web Admin)

* **访问地址**：`http://VPS_IP:9999`
* **核心功能**：
1. **仪表盘**：展示总歌曲数、存储占用统计（逻辑上的）、今日下载量。
2. **缺失补档 (Compensation)**：
* 列出数据库中标记为 `is_missing=true` 或 `file_id` 失效的歌曲。
* 提供“**一键重抓**”按钮，后台触发下载上传流程，更新 `File_ID`。


3. **元数据修正**：(可选) 允许手动编辑歌曲的标题、歌手信息。



---

## 4. 数据需求 (Data Requirements)

### 4.1 核心数据实体

* **Songs (歌曲表)**：
* `unique_hash` (文件指纹，防止重复下载)
* `file_id` (Telegram 核心资产)
* `source_url` (源链接，用于补档)
* `metadata` (JSON 或独立字段：含年份、国家、歌词)
* `status` (正常 / 需补档)


* **Config (配置)**：由 `config.yaml` 静态文件管理，**不入库**。

---

## 5. 非功能性需求 (Non-functional Requirements)

### 5.1 性能与并发

* **并发控制**：下载任务必须使用 **Worker Pool (工作池)** 模式，限制同时进行的下载任务数（如最大 3 个），防止 VPS 内存溢出或被封 IP。
* **响应速度**：
* 库内命中响应时间 < 500ms。
* Web 管理端页面加载时间 < 1s。



### 5.2 安全性

* **权限控制**：
* Bot 的管理命令（如 `/delete`, `/clean`）仅限 `config.yaml` 中配置的 `admin_id` 使用。
* Web 端建议增加基础的 Basic Auth 认证（用户名/密码）。


* **隐私保护**：
* **阅后即焚**：必须确保 `defer os.Remove()` 逻辑覆盖所有上传路径，无论成功与否，本地不留存任何音频文件。



### 5.3 鲁棒性

* **重试机制**：网络请求（下载/上传）失败时，应自动重试 3 次。
* **文件限制**：自动检测源文件大小，超过 50MB 的文件应自动跳过或进行压缩处理（Telegram Bot API 限制）。

---

## 6. 开发交付物 (Deliverables)

1. **源代码**：Golang 源码，包含完整的 `go.mod` 依赖。
2. **配置文件**：`config.yaml.example` 模板。
3. **部署脚本**：`Dockerfile` 及 `docker-compose.yml`（含 Postgres 和 Bot 编排）。
4. **SQL 脚本**：数据库初始化 Schema (`init.sql`)。

---

## 7. 附录：预期用户流程图 (User Flow)

1. **User**: 输入 "Linkin Park Numb"
2. **Bot**: 🔍 查询 DB
* *Case A (命中)*: 返回 Audio (File_ID) ✅
* *Case B (未命中)*:
1. 返回 "下载中..."
2. System: 调用 yt-dlp 下载 -> ffmpeg 嵌入封面/歌词 -> 上传 TG -> 存 DB -> 删本地
3. Bot: 发送 Audio ✅
